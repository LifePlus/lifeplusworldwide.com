---
import Container from './Container.vue'

---

<div id="progress" class="fixed top-0 w-full flex bg-white h-[42px] transition-all ease-in-out shadow-md">
  <Container class="flex justify-between h-full">
    <div id="progress-bar" class="flex h-full items-center border-t border-b-[5px] transition-[width] duration-300 ease-in-out border-brand-primary">
      <img class="h-6 w-auto" src="/assets/lifeplus.svg" alt="LifePlus" />
    </div>
    <div class="flex items-center pl-4 text-gray-500">ENG</div>
  </Container>
</div>

<script>
const masthead = document.getElementById('section-1')
const progress = document.getElementById('progress')
const progressBar = document.getElementById('progress-bar')
const classes = ['-translate-y-full', 'opacity-0']

const handleScroll = throttle(() => {
  const rectangle = masthead.getBoundingClientRect()

  if (rectangle.height + rectangle.top < 0) {
    progress.classList.remove(...classes)
    const winScroll = document.body.scrollTop || document.documentElement.scrollTop
    const height = document.documentElement.scrollHeight - document.documentElement.clientHeight
    const scrolled = Math.round((winScroll / height) * 100)
    progressBar.style.width = `${scrolled}%`
  } else {
    progress.classList.add(...classes)
    progressBar.style.width = `auto`
  }
}, 100, { leading: true, trailing: true })

document.addEventListener('scroll', handleScroll)

function throttle (fn, interval, options) {
  var timeoutId = null;
  var throttledFn = null;
  var leading = (options && options.leading);
  var trailing = (options && options.trailing);

  if (leading == null) {
    leading = true; // default
  }

  if (trailing == null) {
    trailing = !leading; //default
  }

  if (leading == true) {
    trailing = false; // forced because there should be invocation per call
  }

  var cancel = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };

  var flush = function() {
    var call = throttledFn;
    cancel();

    if (call) {
      call();
    }
  };

  var throttleWrapper = function() {
    var callNow = leading && !timeoutId;
    var context = this;
    var args = arguments;

    throttledFn = function() {
      return fn.apply(context, args);
    };

    if (!timeoutId) {
      timeoutId = setTimeout(function() {
        timeoutId = null;

        if (trailing) {
          return throttledFn();
        }
      }, interval);
    }

    if (callNow) {
      callNow = false;
      return throttledFn();
    }
  };

  throttleWrapper.cancel = cancel;
  throttleWrapper.flush = flush;

  return throttleWrapper;
}
</script>